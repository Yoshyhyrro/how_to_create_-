<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>glTF 2.0 Legendre Symbol Processor</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'JetBrains Mono', monospace;
            background: linear-gradient(135deg, #1a0033, #330066, #4d0080);
            color: #e0e0ff;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
        }
        
        .panel {
            background: rgba(224, 224, 255, 0.1);
            border: 1px solid #8080ff;
            border-radius: 12px;
            padding: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(128, 128, 255, 0.2);
        }
        
        .gltf-viewer {
            width: 100%;
            height: 300px;
            border: 2px solid #8080ff;
            background: #000;
            border-radius: 8px;
            position: relative;
            overflow: hidden;
        }
        
        .math-display {
            font-family: 'Latin Modern Math', 'Computer Modern', serif;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #ff6b9d;
            margin: 10px 0;
            font-size: 14px;
        }
        
        .quaternion-display {
            background: rgba(128, 128, 255, 0.2);
            padding: 12px;
            border-radius: 6px;
            font-family: monospace;
            margin: 8px 0;
        }
        
        .legendre-table {
            width: 100%;
            border-collapse: collapse;
            margin: 10px 0;
        }
        
        .legendre-table th, .legendre-table td {
            border: 1px solid #8080ff;
            padding: 8px;
            text-align: center;
        }
        
        .legendre-table th {
            background: rgba(128, 128, 255, 0.3);
        }
        
        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin: 15px 0;
        }
        
        button {
            background: linear-gradient(45deg, #8080ff, #6060cc);
            border: none;
            color: white;
            padding: 10px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }
        
        button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(128, 128, 255, 0.5);
        }
        
        .validation-result {
            padding: 15px;
            margin: 10px 0;
            border-radius: 8px;
            font-weight: bold;
        }
        
        .validation-result.success {
            background: rgba(0, 255, 0, 0.2);
            border: 1px solid #00ff00;
            color: #00ff88;
        }
        
        .validation-result.warning {
            background: rgba(255, 165, 0, 0.2);
            border: 1px solid #ffa500;
            color: #ffcc00;
        }
        
        .validation-result.error {
            background: rgba(255, 0, 0, 0.2);
            border: 1px solid #ff0000;
            color: #ff6666;
        }
        
        .compression-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 15px 0;
        }
        
        .stat-box {
            background: rgba(128, 128, 255, 0.15);
            padding: 12px;
            border-radius: 6px;
            text-align: center;
        }
        
        .prime-field {
            background: rgba(255, 107, 157, 0.2);
            padding: 10px;
            border-radius: 6px;
            margin: 8px 0;
        }
    </style>
</head>
<body>
    <h1 style="text-align: center; text-shadow: 0 0 30px #8080ff;">🔮 glTF 2.0 × Legendre Symbol Processor</h1>
    
    <div class="container">
        <!-- glTF処理パネル -->
        <div class="panel">
            <h2>📐 glTF 2.0 Transform Processing</h2>
            <div id="gltfViewer" class="gltf-viewer">
                <canvas id="gltfCanvas" style="width: 100%; height: 100%;"></canvas>
            </div>
            
            <div class="controls">
                <button onclick="loadSampleGLTF()">サンプル読込</button>
                <button onclick="extractTransforms()">変換抽出</button>
                <button onclick="validateQuaternions()">四元数検証</button>
            </div>
            
            <div class="quaternion-display">
                <h4>Current Quaternion:</h4>
                <div id="currentQuaternion">q = w + xi + yj + zk</div>
                <div id="quaternionMatrix">対応する回転行列が表示されます</div>
            </div>
            
            <div class="compression-stats">
                <div class="stat-box">
                    <div>Nodes</div>
                    <div id="nodeCount">0</div>
                </div>
                <div class="stat-box">
                    <div>Transforms</div>
                    <div id="transformCount">0</div>
                </div>
            </div>
        </div>
        
        <!-- ルジャンドル記号処理パネル -->
        <div class="panel">
            <h2>🔢 Legendre Symbol Analysis</h2>
            
            <div class="math-display">
                <h4>ルジャンドル記号の定義:</h4>
                <div>( a/p ) = a^((p-1)/2) (mod p)</div>
                <div>where p is an odd prime</div>
            </div>
            
            <div class="prime-field">
                <label>Prime p: </label>
                <input type="number" id="primeP" value="17" min="3" step="2">
                <button onclick="updateLegendreTable()">更新</button>
            </div>
            
            <table class="legendre-table" id="legendreTable">
                <thead>
                    <tr><th>a</th><th>(a/p)</th><th>a^((p-1)/2) mod p</th><th>Square Root?</th></tr>
                </thead>
                <tbody></tbody>
            </table>
            
            <div class="controls">
                <button onclick="analyzeQuaternionResidues()">四元数剰余解析</button>
                <button onclick="checkOrthogonality()">直交性チェック</button>
            </div>
            
            <div id="residueAnalysis" class="math-display" style="display: none;">
                <h4>Quadratic Residue Analysis:</h4>
                <div id="residueResults"></div>
            </div>
        </div>
        
        <!-- 整合性検証パネル -->
        <div class="panel">
            <h2>✅ Consistency Validation</h2>
            
            <div id="validationResults">
                <div class="validation-result warning">
                    検証を実行してください
                </div>
            </div>
            
            <div class="controls">
                <button onclick="runFullValidation()">完全検証実行</button>
                <button onclick="testQuaternionLegendre()">四元数-ルジャンドル対応</button>
                <button onclick="benchmarkCompression()">圧縮性能測定</button>
            </div>
            
            <div class="math-display">
                <h4>検証項目:</h4>
                <ul>
                    <li>四元数の正規化 (‖q‖ = 1)</li>
                    <li>回転行列の直交性 (R^T R = I)</li>
                    <li>ルジャンドル記号の相互法則</li>
                    <li>glTF仕様準拠性</li>
                    <li>数値精度の一貫性</li>
                </ul>
            </div>
            
            <div id="compressionComparison" class="compression-stats">
                <div class="stat-box">
                    <div>Standard glTF</div>
                    <div id="standardSize">0 bytes</div>
                </div>
                <div class="stat-box">
                    <div>With Legendre</div>
                    <div id="legendreSize">0 bytes</div>
                </div>
                <div class="stat-box">
                    <div>Jordan Decomp</div>
                    <div id="jordanSize">0 bytes</div>
                </div>
                <div class="stat-box">
                    <div>Best Ratio</div>
                    <div id="bestRatio">0%</div>
                </div>
            </div>
            
            <canvas id="consistencyChart" style="width: 100%; height: 200px; background: #000; border: 1px solid #8080ff; border-radius: 6px;"></canvas>
        </div>
    </div>

    <script>
        class GLTFLegendreProcessor {
            constructor() {
                this.gltfData = null;
                this.transforms = [];
                this.quaternions = [];
                this.primes = [3, 5, 7, 11, 13, 17, 19, 23, 29, 31];
                this.currentPrime = 17;
                
                this.initializeCanvas();
                this.updateLegendreTable();
            }
            
            // キャンバス初期化
            initializeCanvas() {
                this.canvas = document.getElementById('gltfCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.canvas.width = this.canvas.offsetWidth;
                this.canvas.height = this.canvas.offsetHeight;
                
                this.drawSampleScene();
            }
            
            // サンプルシーンの描画
            drawSampleScene() {
                const ctx = this.ctx;
                ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // 背景グラデーション
                const gradient = ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                gradient.addColorStop(0, '#1a0033');
                gradient.addColorStop(1, '#000000');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // サンプルの3Dオブジェクト（キューブ）
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                const time = Date.now() * 0.001;
                
                // 回転する立方体
                this.drawRotatingCube(ctx, centerX, centerY, time);
                
                // 座標軸
                this.drawAxes(ctx, centerX, centerY);
                
                requestAnimationFrame(() => this.drawSampleScene());
            }
            
            drawRotatingCube(ctx, x, y, time) {
                ctx.save();
                ctx.translate(x, y);
                
                // 四元数による回転（サンプル）
                const quat = this.createQuaternion(time * 0.5, time * 0.3, time * 0.7);
                const matrix = this.quaternionToMatrix(quat);
                
                // 現在の四元数を表示
                this.displayCurrentQuaternion(quat);
                
                // 立方体の頂点
                const vertices = [
                    [-30, -30, -30], [30, -30, -30], [30, 30, -30], [-30, 30, -30],
                    [-30, -30, 30], [30, -30, 30], [30, 30, 30], [-30, 30, 30]
                ];
                
                // 行列変換適用
                const transformedVertices = vertices.map(v => this.multiplyMatrixVector(matrix, v));
                
                // 投影と描画
                const projectedVertices = transformedVertices.map(v => [v[0], v[1]]);
                
                // 面の描画
                ctx.strokeStyle = '#8080ff';
                ctx.lineWidth = 2;
                this.drawCubeFaces(ctx, projectedVertices);
                
                ctx.restore();
            }
            
            drawAxes(ctx, x, y) {
                ctx.save();
                ctx.translate(x, y);
                ctx.lineWidth = 2;
                
                // X軸 (赤)
                ctx.strokeStyle = '#ff4444';
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(50, 0);
                ctx.stroke();
                
                // Y軸 (緑)
                ctx.strokeStyle = '#44ff44';
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(0, -50);
                ctx.stroke();
                
                // Z軸 (青) - 斜め表現
                ctx.strokeStyle = '#4444ff';
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(35, 35);
                ctx.stroke();
                
                ctx.restore();
            }
            
            drawCubeFaces(ctx, vertices) {
                const faces = [
                    [0, 1, 2, 3], [4, 5, 6, 7], // 前面・背面
                    [0, 1, 5, 4], [2, 3, 7, 6], // 上面・下面
                    [1, 2, 6, 5], [0, 3, 7, 4]  // 左面・右面
                ];
                
                faces.forEach((face, index) => {
                    ctx.beginPath();
                    ctx.moveTo(vertices[face[0]][0], vertices[face[0]][1]);
                    for (let i = 1; i < face.length; i++) {
                        ctx.lineTo(vertices[face[i]][0], vertices[face[i]][1]);
                    }
                    ctx.closePath();
                    
                    // 面ごとに異なる透明度
                    ctx.fillStyle = `hsla(${index * 60}, 70%, 50%, 0.3)`;
                    ctx.fill();
                    ctx.stroke();
                });
            }
            
            // 四元数生成
            createQuaternion(x, y, z) {
                const w = Math.cos(Math.sqrt(x*x + y*y + z*z) / 2);
                const s = Math.sin(Math.sqrt(x*x + y*y + z*z) / 2);
                const norm = Math.sqrt(x*x + y*y + z*z) || 1;
                
                return {
                    w: w,
                    x: s * x / norm,
                    y: s * y / norm,
                    z: s * z / norm
                };
            }
            
            // 四元数から回転行列への変換
            quaternionToMatrix(q) {
                const { w, x, y, z } = q;
                return [
                    [1-2*(y*y+z*z), 2*(x*y-w*z), 2*(x*z+w*y)],
                    [2*(x*y+w*z), 1-2*(x*x+z*z), 2*(y*z-w*x)],
                    [2*(x*z-w*y), 2*(y*z+w*x), 1-2*(x*x+y*y)]
                ];
            }
            
            // 行列とベクトルの乗算
            multiplyMatrixVector(matrix, vector) {
                return [
                    matrix[0][0] * vector[0] + matrix[0][1] * vector[1] + matrix[0][2] * vector[2],
                    matrix[1][0] * vector[0] + matrix[1][1] * vector[1] + matrix[1][2] * vector[2],
                    matrix[2][0] * vector[0] + matrix[2][1] * vector[1] + matrix[2][2] * vector[2]
                ];
            }
            
            // 現在の四元数表示
            displayCurrentQuaternion(quat) {
                const quatDiv = document.getElementById('currentQuaternion');
                const matrixDiv = document.getElementById('quaternionMatrix');
                
                quatDiv.textContent = `q = ${quat.w.toFixed(3)} + ${quat.x.toFixed(3)}i + ${quat.y.toFixed(3)}j + ${quat.z.toFixed(3)}k`;
                
                const matrix = this.quaternionToMatrix(quat);
                const matrixStr = matrix.map(row => 
                    '[' + row.map(val => val.toFixed(3).padStart(7)).join(' ') + ']'
                ).join('\n');
                matrixDiv.textContent = matrixStr;
            }
            
            // ルジャンドル記号計算
            legendreSymbol(a, p) {
                if (a % p === 0) return 0;
                const result = this.modPow(a, (p - 1) / 2, p);
                return result === 1 ? 1 : -1;
            }
            
            // モジュラー指数計算
            modPow(base, exp, mod) {
                let result = 1;
                base = base % mod;
                while (exp > 0) {
                    if (exp % 2 === 1) {
                        result = (result * base) % mod;
                    }
                    exp = Math.floor(exp / 2);
                    base = (base * base) % mod;
                }
                return result;
            }
            
            // ルジャンドル記号テーブル更新
            updateLegendreTable() {
                const p = parseInt(document.getElementById('primeP').value);
                if (!this.isPrime(p) || p < 3) {
                    alert('3以上の奇数の素数を入力してください');
                    return;
                }
                
                this.currentPrime = p;
                const tbody = document.querySelector('#legendreTable tbody');
                tbody.innerHTML = '';
                
                for (let a = 1; a < p; a++) {
                    const legendreVal = this.legendreSymbol(a, p);
                    const powerVal = this.modPow(a, (p - 1) / 2, p);
                    const isQuadResidue = legendreVal === 1;
                    
                    const row = tbody.insertRow();
                    row.insertCell(0).textContent = a;
                    row.insertCell(1).textContent = legendreVal;
                    row.insertCell(2).textContent = powerVal;
                    row.insertCell(3).textContent = isQuadResidue ? '✓' : '✗';
                    
                    if (isQuadResidue) {
                        row.style.backgroundColor = 'rgba(0, 255, 0, 0.1)';
                    }
                }
            }
            
            // 素数判定
            isPrime(n) {
                if (n < 2) return false;
                for (let i = 2; i <= Math.sqrt(n); i++) {
                    if (n % i === 0) return false;
                }
                return true;
            }
            
            // 四元数の二次剰余解析
            analyzeQuaternionResidues() {
                const resultsDiv = document.getElementById('residueResults');
                const analysisDiv = document.getElementById('residueAnalysis');
                
                // 現在の四元数を取得
                const time = Date.now() * 0.001;
                const quat = this.createQuaternion(time * 0.5, time * 0.3, time * 0.7);
                
                let results = `<h5>四元数成分の二次剰余性:</h5>`;
                
                ['w', 'x', 'y', 'z'].forEach(component => {
                    const value = Math.abs(quat[component]);
                    const scaledValue = Math.floor(value * 100) % this.currentPrime;
                    if (scaledValue !== 0) {
                        const legendre = this.legendreSymbol(scaledValue, this.currentPrime);
                        results += `<div>${component}: ${value.toFixed(3)} → ${scaledValue} → (${scaledValue}/${this.currentPrime}) = ${legendre}</div>`;
                    }
                });
                
                resultsDiv.innerHTML = results;
                analysisDiv.style.display = 'block';
            }
            
            // 完全検証実行
            runFullValidation() {
                const resultsDiv = document.getElementById('validationResults');
                let validationResults = [];
                
                // 1. 四元数正規化チェック
                const time = Date.now() * 0.001;
                const quat = this.createQuaternion(time * 0.5, time * 0.3, time * 0.7);
                const norm = Math.sqrt(quat.w*quat.w + quat.x*quat.x + quat.y*quat.y + quat.z*quat.z);
                const normalizedCheck = Math.abs(norm - 1) < 1e-10;
                
                validationResults.push({
                    test: '四元数正規化',
                    result: normalizedCheck,
                    details: `‖q‖ = ${norm.toFixed(10)}`
                });
                
                // 2. 回転行列直交性チェック
                const matrix = this.quaternionToMatrix(quat);
                const orthogonalCheck = this.checkOrthogonality(matrix);
                
                validationResults.push({
                    test: '回転行列直交性',
                    result: orthogonalCheck.isOrthogonal,
                    details: `det(R) = ${orthogonalCheck.determinant.toFixed(6)}`
                });
                
                // 3. ルジャンドル記号相互法則チェック
                const reciprocityCheck = this.checkQuadraticReciprocity();
                
                validationResults.push({
                    test: 'ルジャンドル相互法則',
                    result: reciprocityCheck,
                    details: 'p ≡ 1 (mod 4) の場合の相互法則'
                });
                
                // 結果表示
                resultsDiv.innerHTML = validationResults.map(result => `
                    <div class="validation-result ${result.result ? 'success' : 'error'}">
                        <strong>${result.test}:</strong> ${result.result ? '✓ 合格' : '✗ 不合格'}
                        <br><small>${result.details}</small>
                    </div>
                `).join('');
                
                this.drawConsistencyChart(validationResults);
            }
            
            // 直交性チェック
            checkOrthogonality(matrix) {
                // R^T * R を計算
                const transpose = this.transposeMatrix(matrix);
                const product = this.multiplyMatrices(transpose, matrix);
                
                // 単位行列からの誤差を計算
                let maxError = 0;
                for (let i = 0; i < 3; i++) {
                    for (let j = 0; j < 3; j++) {
                        const expected = i === j ? 1 : 0;
                        const error = Math.abs(product[i][j] - expected);
                        maxError = Math.max(maxError, error);
                    }
                }
                
                const determinant = this.determinant3x3(matrix);
                
                return {
                    isOrthogonal: maxError < 1e-10 && Math.abs(determinant - 1) < 1e-10,
                    determinant: determinant,
                    maxError: maxError
                };
            }
            
            // 行列の転置
            transposeMatrix(matrix) {
                return matrix[0].map((_, colIndex) => matrix.map(row => row[colIndex]));
            }
            
            // 行列の乗算
            multiplyMatrices(a, b) {
                const result = [];
                for (let i = 0; i < a.length; i++) {
                    result[i] = [];
                    for (let j = 0; j < b[0].length; j++) {
                        let sum = 0;
                        for (let k = 0; k < b.length; k++) {
                            sum += a[i][k] * b[k][j];
                        }
                        result[i][j] = sum;
                    }
                }
                return result;
            }
            
            // 3x3行列式計算
            determinant3x3(matrix) {
                const [[a, b, c], [d, e, f], [g, h, i]] = matrix;
                return a*(e*i - f*h) - b*(d*i - f*g) + c*(d*h - e*g);
            }
            
            // 二次相互法則チェック
            checkQuadraticReciprocity() {
                const p = this.currentPrime;
                const q = 13; // テスト用の別の素数
                
                if (p === q) return true;
                
                const legendre_p_q = this.legendreSymbol(p, q);
                const legendre_q_p = this.legendreSymbol(q, p);
                
                // 相互法則: (p/q)(q/p) = (-1)^((p-1)/2 * (q-1)/2)
                const expected = Math.pow(-1, ((p-1)/2) * ((q-1)/2));
                const actual = legendre_p_q * legendre_q_p;
                
                return actual === expected;
            }
            
            // 整合性チャートの描画
            drawConsistencyChart(results) {
                const canvas = document.getElementById('consistencyChart');
                const ctx = canvas.getContext('2d');
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const passedTests = results.filter(r => r.result).length;
                const totalTests = results.length;
                const successRate = passedTests / totalTests;
                
                // 円グラフで成功率を表示
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const radius = Math.min(centerX, centerY) - 20;
                
                // 成功部分
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI * successRate);
                ctx.lineTo(centerX, centerY);
                ctx.fillStyle = '#00ff88';
                ctx.fill();
                
                // 失敗部分
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 2 * Math.PI * successRate, 2 * Math.PI);
                ctx.lineTo(centerX, centerY);
                ctx.fillStyle = '#ff6666';
                ctx.fill();
                
                // 外枠
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                ctx.strokeStyle = '#8080ff';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // テキスト表示
                ctx.fillStyle = '#e0e0ff';
                ctx.font = '16px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(`${passedTests}/${totalTests} Tests Passed`, centerX, centerY - 10);
                ctx.fillText(`${(successRate * 100).toFixed(1)}% Success Rate`, centerX, centerY + 10);
            }
            
            // 圧縮性能ベンチマーク
            benchmarkCompression() {
                const standardSize = 16 * 4; // 4x4行列 * 4バイト/float
                const gltfQuatSize = 4 * 4 + 3 * 4 + 3 * 4; // quat + translation + scale
                const jordanSize = 2 * 8 + 2 * 4 + 1 * 4; // 固有値 + スケール + 回転
                const legendreSize = 4 + 2 * 4; // 素数 + 剰余2個
                
                document.getElementById('standardSize').textContent = standardSize + ' bytes';
                document.getElementById('legendreSize').textContent = (gltfQuatSize + legendreSize) + ' bytes';