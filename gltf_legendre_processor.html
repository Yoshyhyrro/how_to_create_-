<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>glTF 2.0 Legendre Symbol Processor</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'JetBrains Mono', monospace;
            background: linear-gradient(135deg, #1a0033, #330066, #4d0080);
            color: #e0e0ff;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
        }
        
        .panel {
            background: rgba(224, 224, 255, 0.1);
            border: 1px solid #8080ff;
            border-radius: 12px;
            padding: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(128, 128, 255, 0.2);
        }
        
        .gltf-viewer {
            width: 100%;
            height: 300px;
            border: 2px solid #8080ff;
            background: #000;
            border-radius: 8px;
            position: relative;
            overflow: hidden;
        }
        
        .math-display {
            font-family: 'Latin Modern Math', 'Computer Modern', serif;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #ff6b9d;
            margin: 10px 0;
            font-size: 14px;
        }
        
        .quaternion-display {
            background: rgba(128, 128, 255, 0.2);
            padding: 12px;
            border-radius: 6px;
            font-family: monospace;
            margin: 8px 0;
        }
        
        .legendre-table {
            width: 100%;
            border-collapse: collapse;
            margin: 10px 0;
        }
        
        .legendre-table th, .legendre-table td {
            border: 1px solid #8080ff;
            padding: 8px;
            text-align: center;
        }
        
        .legendre-table th {
            background: rgba(128, 128, 255, 0.3);
        }
        
        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin: 15px 0;
        }
        
        button {
            background: linear-gradient(45deg, #8080ff, #6060cc);
            border: none;
            color: white;
            padding: 10px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }
        
        button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(128, 128, 255, 0.5);
        }
        
        .validation-result {
            padding: 15px;
            margin: 10px 0;
            border-radius: 8px;
            font-weight: bold;
        }
        
        .validation-result.success {
            background: rgba(0, 255, 0, 0.2);
            border: 1px solid #00ff00;
            color: #00ff88;
        }
        
        .validation-result.warning {
            background: rgba(255, 165, 0, 0.2);
            border: 1px solid #ffa500;
            color: #ffcc00;
        }
        
        .validation-result.error {
            background: rgba(255, 0, 0, 0.2);
            border: 1px solid #ff0000;
            color: #ff6666;
        }
        
        .compression-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 15px 0;
        }
        
        .stat-box {
            background: rgba(128, 128, 255, 0.15);
            padding: 12px;
            border-radius: 6px;
            text-align: center;
        }
        
        .prime-field {
            background: rgba(255, 107, 157, 0.2);
            padding: 10px;
            border-radius: 6px;
            margin: 8px 0;
        }
    </style>
</head>
<body>
    <h1 style="text-align: center; text-shadow: 0 0 30px #8080ff;">ğŸ”® glTF 2.0 Ã— Legendre Symbol Processor</h1>
    
    <div class="container">
        <!-- glTFå‡¦ç†ãƒ‘ãƒãƒ« -->
        <div class="panel">
            <h2>ğŸ“ glTF 2.0 Transform Processing</h2>
            <div id="gltfViewer" class="gltf-viewer">
                <canvas id="gltfCanvas" style="width: 100%; height: 100%;"></canvas>
            </div>
            
            <div class="controls">
                <button onclick="loadSampleGLTF()">ã‚µãƒ³ãƒ—ãƒ«èª­è¾¼</button>
                <button onclick="extractTransforms()">å¤‰æ›æŠ½å‡º</button>
                <button onclick="validateQuaternions()">å››å…ƒæ•°æ¤œè¨¼</button>
            </div>
            
            <div class="quaternion-display">
                <h4>Current Quaternion:</h4>
                <div id="currentQuaternion">q = w + xi + yj + zk</div>
                <div id="quaternionMatrix">å¯¾å¿œã™ã‚‹å›è»¢è¡Œåˆ—ãŒè¡¨ç¤ºã•ã‚Œã¾ã™</div>
            </div>
            
            <div class="compression-stats">
                <div class="stat-box">
                    <div>Nodes</div>
                    <div id="nodeCount">0</div>
                </div>
                <div class="stat-box">
                    <div>Transforms</div>
                    <div id="transformCount">0</div>
                </div>
            </div>
        </div>
        
        <!-- ãƒ«ã‚¸ãƒ£ãƒ³ãƒ‰ãƒ«è¨˜å·å‡¦ç†ãƒ‘ãƒãƒ« -->
        <div class="panel">
            <h2>ğŸ”¢ Legendre Symbol Analysis</h2>
            
            <div class="math-display">
                <h4>ãƒ«ã‚¸ãƒ£ãƒ³ãƒ‰ãƒ«è¨˜å·ã®å®šç¾©:</h4>
                <div>( a/p ) = a^((p-1)/2) (mod p)</div>
                <div>where p is an odd prime</div>
            </div>
            
            <div class="prime-field">
                <label>Prime p: </label>
                <input type="number" id="primeP" value="17" min="3" step="2">
                <button onclick="updateLegendreTable()">æ›´æ–°</button>
            </div>
            
            <table class="legendre-table" id="legendreTable">
                <thead>
                    <tr><th>a</th><th>(a/p)</th><th>a^((p-1)/2) mod p</th><th>Square Root?</th></tr>
                </thead>
                <tbody></tbody>
            </table>
            
            <div class="controls">
                <button onclick="analyzeQuaternionResidues()">å››å…ƒæ•°å‰°ä½™è§£æ</button>
                <button onclick="checkOrthogonality()">ç›´äº¤æ€§ãƒã‚§ãƒƒã‚¯</button>
            </div>
            
            <div id="residueAnalysis" class="math-display" style="display: none;">
                <h4>Quadratic Residue Analysis:</h4>
                <div id="residueResults"></div>
            </div>
        </div>
        
        <!-- æ•´åˆæ€§æ¤œè¨¼ãƒ‘ãƒãƒ« -->
        <div class="panel">
            <h2>âœ… Consistency Validation</h2>
            
            <div id="validationResults">
                <div class="validation-result warning">
                    æ¤œè¨¼ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„
                </div>
            </div>
            
            <div class="controls">
                <button onclick="runFullValidation()">å®Œå…¨æ¤œè¨¼å®Ÿè¡Œ</button>
                <button onclick="testQuaternionLegendre()">å››å…ƒæ•°-ãƒ«ã‚¸ãƒ£ãƒ³ãƒ‰ãƒ«å¯¾å¿œ</button>
                <button onclick="benchmarkCompression()">åœ§ç¸®æ€§èƒ½æ¸¬å®š</button>
            </div>
            
            <div class="math-display">
                <h4>æ¤œè¨¼é …ç›®:</h4>
                <ul>
                    <li>å››å…ƒæ•°ã®æ­£è¦åŒ– (â€–qâ€– = 1)</li>
                    <li>å›è»¢è¡Œåˆ—ã®ç›´äº¤æ€§ (R^T R = I)</li>
                    <li>ãƒ«ã‚¸ãƒ£ãƒ³ãƒ‰ãƒ«è¨˜å·ã®ç›¸äº’æ³•å‰‡</li>
                    <li>glTFä»•æ§˜æº–æ‹ æ€§</li>
                    <li>æ•°å€¤ç²¾åº¦ã®ä¸€è²«æ€§</li>
                </ul>
            </div>
            
            <div id="compressionComparison" class="compression-stats">
                <div class="stat-box">
                    <div>Standard glTF</div>
                    <div id="standardSize">0 bytes</div>
                </div>
                <div class="stat-box">
                    <div>With Legendre</div>
                    <div id="legendreSize">0 bytes</div>
                </div>
                <div class="stat-box">
                    <div>Jordan Decomp</div>
                    <div id="jordanSize">0 bytes</div>
                </div>
                <div class="stat-box">
                    <div>Best Ratio</div>
                    <div id="bestRatio">0%</div>
                </div>
            </div>
            
            <canvas id="consistencyChart" style="width: 100%; height: 200px; background: #000; border: 1px solid #8080ff; border-radius: 6px;"></canvas>
        </div>
    </div>

    <script>
        class GLTFLegendreProcessor {
            constructor() {
                this.gltfData = null;
                this.transforms = [];
                this.quaternions = [];
                this.primes = [3, 5, 7, 11, 13, 17, 19, 23, 29, 31];
                this.currentPrime = 17;
                
                this.initializeCanvas();
                this.updateLegendreTable();
            }
            
            // ã‚­ãƒ£ãƒ³ãƒã‚¹åˆæœŸåŒ–
            initializeCanvas() {
                this.canvas = document.getElementById('gltfCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.canvas.width = this.canvas.offsetWidth;
                this.canvas.height = this.canvas.offsetHeight;
                
                this.drawSampleScene();
            }
            
            // ã‚µãƒ³ãƒ—ãƒ«ã‚·ãƒ¼ãƒ³ã®æç”»
            drawSampleScene() {
                const ctx = this.ctx;
                ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // èƒŒæ™¯ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
                const gradient = ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                gradient.addColorStop(0, '#1a0033');
                gradient.addColorStop(1, '#000000');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // ã‚µãƒ³ãƒ—ãƒ«ã®3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆï¼ˆã‚­ãƒ¥ãƒ¼ãƒ–ï¼‰
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                const time = Date.now() * 0.001;
                
                // å›è»¢ã™ã‚‹ç«‹æ–¹ä½“
                this.drawRotatingCube(ctx, centerX, centerY, time);
                
                // åº§æ¨™è»¸
                this.drawAxes(ctx, centerX, centerY);
                
                requestAnimationFrame(() => this.drawSampleScene());
            }
            
            drawRotatingCube(ctx, x, y, time) {
                ctx.save();
                ctx.translate(x, y);
                
                // å››å…ƒæ•°ã«ã‚ˆã‚‹å›è»¢ï¼ˆã‚µãƒ³ãƒ—ãƒ«ï¼‰
                const quat = this.createQuaternion(time * 0.5, time * 0.3, time * 0.7);
                const matrix = this.quaternionToMatrix(quat);
                
                // ç¾åœ¨ã®å››å…ƒæ•°ã‚’è¡¨ç¤º
                this.displayCurrentQuaternion(quat);
                
                // ç«‹æ–¹ä½“ã®é ‚ç‚¹
                const vertices = [
                    [-30, -30, -30], [30, -30, -30], [30, 30, -30], [-30, 30, -30],
                    [-30, -30, 30], [30, -30, 30], [30, 30, 30], [-30, 30, 30]
                ];
                
                // è¡Œåˆ—å¤‰æ›é©ç”¨
                const transformedVertices = vertices.map(v => this.multiplyMatrixVector(matrix, v));
                
                // æŠ•å½±ã¨æç”»
                const projectedVertices = transformedVertices.map(v => [v[0], v[1]]);
                
                // é¢ã®æç”»
                ctx.strokeStyle = '#8080ff';
                ctx.lineWidth = 2;
                this.drawCubeFaces(ctx, projectedVertices);
                
                ctx.restore();
            }
            
            drawAxes(ctx, x, y) {
                ctx.save();
                ctx.translate(x, y);
                ctx.lineWidth = 2;
                
                // Xè»¸ (èµ¤)
                ctx.strokeStyle = '#ff4444';
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(50, 0);
                ctx.stroke();
                
                // Yè»¸ (ç·‘)
                ctx.strokeStyle = '#44ff44';
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(0, -50);
                ctx.stroke();
                
                // Zè»¸ (é’) - æ–œã‚è¡¨ç¾
                ctx.strokeStyle = '#4444ff';
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(35, 35);
                ctx.stroke();
                
                ctx.restore();
            }
            
            drawCubeFaces(ctx, vertices) {
                const faces = [
                    [0, 1, 2, 3], [4, 5, 6, 7], // å‰é¢ãƒ»èƒŒé¢
                    [0, 1, 5, 4], [2, 3, 7, 6], // ä¸Šé¢ãƒ»ä¸‹é¢
                    [1, 2, 6, 5], [0, 3, 7, 4]  // å·¦é¢ãƒ»å³é¢
                ];
                
                faces.forEach((face, index) => {
                    ctx.beginPath();
                    ctx.moveTo(vertices[face[0]][0], vertices[face[0]][1]);
                    for (let i = 1; i < face.length; i++) {
                        ctx.lineTo(vertices[face[i]][0], vertices[face[i]][1]);
                    }
                    ctx.closePath();
                    
                    // é¢ã”ã¨ã«ç•°ãªã‚‹é€æ˜åº¦
                    ctx.fillStyle = `hsla(${index * 60}, 70%, 50%, 0.3)`;
                    ctx.fill();
                    ctx.stroke();
                });
            }
            
            // å››å…ƒæ•°ç”Ÿæˆ
            createQuaternion(x, y, z) {
                const w = Math.cos(Math.sqrt(x*x + y*y + z*z) / 2);
                const s = Math.sin(Math.sqrt(x*x + y*y + z*z) / 2);
                const norm = Math.sqrt(x*x + y*y + z*z) || 1;
                
                return {
                    w: w,
                    x: s * x / norm,
                    y: s * y / norm,
                    z: s * z / norm
                };
            }
            
            // å››å…ƒæ•°ã‹ã‚‰å›è»¢è¡Œåˆ—ã¸ã®å¤‰æ›
            quaternionToMatrix(q) {
                const { w, x, y, z } = q;
                return [
                    [1-2*(y*y+z*z), 2*(x*y-w*z), 2*(x*z+w*y)],
                    [2*(x*y+w*z), 1-2*(x*x+z*z), 2*(y*z-w*x)],
                    [2*(x*z-w*y), 2*(y*z+w*x), 1-2*(x*x+y*y)]
                ];
            }
            
            // è¡Œåˆ—ã¨ãƒ™ã‚¯ãƒˆãƒ«ã®ä¹—ç®—
            multiplyMatrixVector(matrix, vector) {
                return [
                    matrix[0][0] * vector[0] + matrix[0][1] * vector[1] + matrix[0][2] * vector[2],
                    matrix[1][0] * vector[0] + matrix[1][1] * vector[1] + matrix[1][2] * vector[2],
                    matrix[2][0] * vector[0] + matrix[2][1] * vector[1] + matrix[2][2] * vector[2]
                ];
            }
            
            // ç¾åœ¨ã®å››å…ƒæ•°è¡¨ç¤º
            displayCurrentQuaternion(quat) {
                const quatDiv = document.getElementById('currentQuaternion');
                const matrixDiv = document.getElementById('quaternionMatrix');
                
                quatDiv.textContent = `q = ${quat.w.toFixed(3)} + ${quat.x.toFixed(3)}i + ${quat.y.toFixed(3)}j + ${quat.z.toFixed(3)}k`;
                
                const matrix = this.quaternionToMatrix(quat);
                const matrixStr = matrix.map(row => 
                    '[' + row.map(val => val.toFixed(3).padStart(7)).join(' ') + ']'
                ).join('\n');
                matrixDiv.textContent = matrixStr;
            }
            
            // ãƒ«ã‚¸ãƒ£ãƒ³ãƒ‰ãƒ«è¨˜å·è¨ˆç®—
            legendreSymbol(a, p) {
                if (a % p === 0) return 0;
                const result = this.modPow(a, (p - 1) / 2, p);
                return result === 1 ? 1 : -1;
            }
            
            // ãƒ¢ã‚¸ãƒ¥ãƒ©ãƒ¼æŒ‡æ•°è¨ˆç®—
            modPow(base, exp, mod) {
                let result = 1;
                base = base % mod;
                while (exp > 0) {
                    if (exp % 2 === 1) {
                        result = (result * base) % mod;
                    }
                    exp = Math.floor(exp / 2);
                    base = (base * base) % mod;
                }
                return result;
            }
            
            // ãƒ«ã‚¸ãƒ£ãƒ³ãƒ‰ãƒ«è¨˜å·ãƒ†ãƒ¼ãƒ–ãƒ«æ›´æ–°
            updateLegendreTable() {
                const p = parseInt(document.getElementById('primeP').value);
                if (!this.isPrime(p) || p < 3) {
                    alert('3ä»¥ä¸Šã®å¥‡æ•°ã®ç´ æ•°ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
                    return;
                }
                
                this.currentPrime = p;
                const tbody = document.querySelector('#legendreTable tbody');
                tbody.innerHTML = '';
                
                for (let a = 1; a < p; a++) {
                    const legendreVal = this.legendreSymbol(a, p);
                    const powerVal = this.modPow(a, (p - 1) / 2, p);
                    const isQuadResidue = legendreVal === 1;
                    
                    const row = tbody.insertRow();
                    row.insertCell(0).textContent = a;
                    row.insertCell(1).textContent = legendreVal;
                    row.insertCell(2).textContent = powerVal;
                    row.insertCell(3).textContent = isQuadResidue ? 'âœ“' : 'âœ—';
                    
                    if (isQuadResidue) {
                        row.style.backgroundColor = 'rgba(0, 255, 0, 0.1)';
                    }
                }
            }
            
            // ç´ æ•°åˆ¤å®š
            isPrime(n) {
                if (n < 2) return false;
                for (let i = 2; i <= Math.sqrt(n); i++) {
                    if (n % i === 0) return false;
                }
                return true;
            }
            
            // å››å…ƒæ•°ã®äºŒæ¬¡å‰°ä½™è§£æ
            analyzeQuaternionResidues() {
                const resultsDiv = document.getElementById('residueResults');
                const analysisDiv = document.getElementById('residueAnalysis');
                
                // ç¾åœ¨ã®å››å…ƒæ•°ã‚’å–å¾—
                const time = Date.now() * 0.001;
                const quat = this.createQuaternion(time * 0.5, time * 0.3, time * 0.7);
                
                let results = `<h5>å››å…ƒæ•°æˆåˆ†ã®äºŒæ¬¡å‰°ä½™æ€§:</h5>`;
                
                ['w', 'x', 'y', 'z'].forEach(component => {
                    const value = Math.abs(quat[component]);
                    const scaledValue = Math.floor(value * 100) % this.currentPrime;
                    if (scaledValue !== 0) {
                        const legendre = this.legendreSymbol(scaledValue, this.currentPrime);
                        results += `<div>${component}: ${value.toFixed(3)} â†’ ${scaledValue} â†’ (${scaledValue}/${this.currentPrime}) = ${legendre}</div>`;
                    }
                });
                
                resultsDiv.innerHTML = results;
                analysisDiv.style.display = 'block';
            }
            
            // å®Œå…¨æ¤œè¨¼å®Ÿè¡Œ
            runFullValidation() {
                const resultsDiv = document.getElementById('validationResults');
                let validationResults = [];
                
                // 1. å››å…ƒæ•°æ­£è¦åŒ–ãƒã‚§ãƒƒã‚¯
                const time = Date.now() * 0.001;
                const quat = this.createQuaternion(time * 0.5, time * 0.3, time * 0.7);
                const norm = Math.sqrt(quat.w*quat.w + quat.x*quat.x + quat.y*quat.y + quat.z*quat.z);
                const normalizedCheck = Math.abs(norm - 1) < 1e-10;
                
                validationResults.push({
                    test: 'å››å…ƒæ•°æ­£è¦åŒ–',
                    result: normalizedCheck,
                    details: `â€–qâ€– = ${norm.toFixed(10)}`
                });
                
                // 2. å›è»¢è¡Œåˆ—ç›´äº¤æ€§ãƒã‚§ãƒƒã‚¯
                const matrix = this.quaternionToMatrix(quat);
                const orthogonalCheck = this.checkOrthogonality(matrix);
                
                validationResults.push({
                    test: 'å›è»¢è¡Œåˆ—ç›´äº¤æ€§',
                    result: orthogonalCheck.isOrthogonal,
                    details: `det(R) = ${orthogonalCheck.determinant.toFixed(6)}`
                });
                
                // 3. ãƒ«ã‚¸ãƒ£ãƒ³ãƒ‰ãƒ«è¨˜å·ç›¸äº’æ³•å‰‡ãƒã‚§ãƒƒã‚¯
                const reciprocityCheck = this.checkQuadraticReciprocity();
                
                validationResults.push({
                    test: 'ãƒ«ã‚¸ãƒ£ãƒ³ãƒ‰ãƒ«ç›¸äº’æ³•å‰‡',
                    result: reciprocityCheck,
                    details: 'p â‰¡ 1 (mod 4) ã®å ´åˆã®ç›¸äº’æ³•å‰‡'
                });
                
                // çµæœè¡¨ç¤º
                resultsDiv.innerHTML = validationResults.map(result => `
                    <div class="validation-result ${result.result ? 'success' : 'error'}">
                        <strong>${result.test}:</strong> ${result.result ? 'âœ“ åˆæ ¼' : 'âœ— ä¸åˆæ ¼'}
                        <br><small>${result.details}</small>
                    </div>
                `).join('');
                
                this.drawConsistencyChart(validationResults);
            }
            
            // ç›´äº¤æ€§ãƒã‚§ãƒƒã‚¯
            checkOrthogonality(matrix) {
                // R^T * R ã‚’è¨ˆç®—
                const transpose = this.transposeMatrix(matrix);
                const product = this.multiplyMatrices(transpose, matrix);
                
                // å˜ä½è¡Œåˆ—ã‹ã‚‰ã®èª¤å·®ã‚’è¨ˆç®—
                let maxError = 0;
                for (let i = 0; i < 3; i++) {
                    for (let j = 0; j < 3; j++) {
                        const expected = i === j ? 1 : 0;
                        const error = Math.abs(product[i][j] - expected);
                        maxError = Math.max(maxError, error);
                    }
                }
                
                const determinant = this.determinant3x3(matrix);
                
                return {
                    isOrthogonal: maxError < 1e-10 && Math.abs(determinant - 1) < 1e-10,
                    determinant: determinant,
                    maxError: maxError
                };
            }
            
            // è¡Œåˆ—ã®è»¢ç½®
            transposeMatrix(matrix) {
                return matrix[0].map((_, colIndex) => matrix.map(row => row[colIndex]));
            }
            
            // è¡Œåˆ—ã®ä¹—ç®—
            multiplyMatrices(a, b) {
                const result = [];
                for (let i = 0; i < a.length; i++) {
                    result[i] = [];
                    for (let j = 0; j < b[0].length; j++) {
                        let sum = 0;
                        for (let k = 0; k < b.length; k++) {
                            sum += a[i][k] * b[k][j];
                        }
                        result[i][j] = sum;
                    }
                }
                return result;
            }
            
            // 3x3è¡Œåˆ—å¼è¨ˆç®—
            determinant3x3(matrix) {
                const [[a, b, c], [d, e, f], [g, h, i]] = matrix;
                return a*(e*i - f*h) - b*(d*i - f*g) + c*(d*h - e*g);
            }
            
            // äºŒæ¬¡ç›¸äº’æ³•å‰‡ãƒã‚§ãƒƒã‚¯
            checkQuadraticReciprocity() {
                const p = this.currentPrime;
                const q = 13; // ãƒ†ã‚¹ãƒˆç”¨ã®åˆ¥ã®ç´ æ•°
                
                if (p === q) return true;
                
                const legendre_p_q = this.legendreSymbol(p, q);
                const legendre_q_p = this.legendreSymbol(q, p);
                
                // ç›¸äº’æ³•å‰‡: (p/q)(q/p) = (-1)^((p-1)/2 * (q-1)/2)
                const expected = Math.pow(-1, ((p-1)/2) * ((q-1)/2));
                const actual = legendre_p_q * legendre_q_p;
                
                return actual === expected;
            }
            
            // æ•´åˆæ€§ãƒãƒ£ãƒ¼ãƒˆã®æç”»
            drawConsistencyChart(results) {
                const canvas = document.getElementById('consistencyChart');
                const ctx = canvas.getContext('2d');
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const passedTests = results.filter(r => r.result).length;
                const totalTests = results.length;
                const successRate = passedTests / totalTests;
                
                // å††ã‚°ãƒ©ãƒ•ã§æˆåŠŸç‡ã‚’è¡¨ç¤º
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const radius = Math.min(centerX, centerY) - 20;
                
                // æˆåŠŸéƒ¨åˆ†
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI * successRate);
                ctx.lineTo(centerX, centerY);
                ctx.fillStyle = '#00ff88';
                ctx.fill();
                
                // å¤±æ•—éƒ¨åˆ†
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 2 * Math.PI * successRate, 2 * Math.PI);
                ctx.lineTo(centerX, centerY);
                ctx.fillStyle = '#ff6666';
                ctx.fill();
                
                // å¤–æ 
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                ctx.strokeStyle = '#8080ff';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // ãƒ†ã‚­ã‚¹ãƒˆè¡¨ç¤º
                ctx.fillStyle = '#e0e0ff';
                ctx.font = '16px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(`${passedTests}/${totalTests} Tests Passed`, centerX, centerY - 10);
                ctx.fillText(`${(successRate * 100).toFixed(1)}% Success Rate`, centerX, centerY + 10);
            }
            
            // åœ§ç¸®æ€§èƒ½ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯
            benchmarkCompression() {
                const standardSize = 16 * 4; // 4x4è¡Œåˆ— * 4ãƒã‚¤ãƒˆ/float
                const gltfQuatSize = 4 * 4 + 3 * 4 + 3 * 4; // quat + translation + scale
                const jordanSize = 2 * 8 + 2 * 4 + 1 * 4; // å›ºæœ‰å€¤ + ã‚¹ã‚±ãƒ¼ãƒ« + å›è»¢
                const legendreSize = 4 + 2 * 4; // ç´ æ•° + å‰°ä½™2å€‹
                
                document.getElementById('standardSize').textContent = standardSize + ' bytes';
                document.getElementById('legendreSize').textContent = (gltfQuatSize + legendreSize) + ' bytes';